\section{Evaluation}\seclabel{Evaluation}
\todo{%
  Revise evaluation section:
    - show fluent output.
    - show throughput of redis and S3 when traced by SPADE.
    - emphasize prototype nature of shim overheads.
    - reduce size of evaluation.
    - run spade on a hand-written KVS to show that spade can produce smaller
      output.
}

We now evaluate the succinctness of the provenance produced by \fluent{}, the
complexity of writing \watprovenance{} specifications, and the performance
overheads of \fluent{} shims.

\subsection{Provenance Succinctness: A Case Study}
SPADE~\cite{gehani2012spade} is a framework for collecting provenance
information in distributed systems composed of arbitrary black boxes. SPADE
collects provenance information from a variety of sources including operating
system audit logs, network artifacts, LLVM instrumented applications, and
applications dynamically instrumented for taint analysis. These techniques are
the current state of the art in extracting the provenance of arbitrary black
boxes.

In this section, we compare the provenance information produced by SPADE (using
kernel auditing and using LLVM instrumentation) against the provenance
information produced by \fluent{}. To do so, we apply SPADE and \fluent{} to a
trivial workload that consists of a single get request and a single set request
to the same key issued against a Redis database. Momentarily, we will see that
even for this trivial workload, \fluent{} produces \watprovenance{} that is
orders of magnitude more succinct than the provenance produced by SPADE.

{\input{figures/spade}}

\paragraph{SPADE (Kernel Auditing)}
The Linux kernel includes an auditing subsystem that records security related
events that take place on a system. For example, the auditing subsystem can
intercept and record the syscalls that are issued by processess running on the
system. Thus, the auditing subsystem can record when sockets are opened, when
files are read from or written to, when processes are launched, etc. We
configured SPADE to capture the information produced by this auditing subsystem
during the exuection of our trivial set and get Redis workload. SPADE produced
a provenance graph with 191 vertices and 896 edges. A small sample of the
information stored in the vertices is shown in \figref{SyscallProv}.

This type of kernel audit provenance has two major flaws. The first and most
notable is that it includes a large amount of low-level information that is
difficult to understand. Before a developer can debug with the kernel audit
provenance, they must first have a strong understanding of the various Linux
syscalls. Then, they must understand when and why Redis issues these syscalls,
which requires a deep understanding of Redis' implementation. Second, the
kernel audit provenance doesn't include some vital pieces of information that
are required to understand the workload. Notably, syscalls do not capture
writes to memory, so they do not provide visibility into the fact that our get
request reads from the same memory location as the previous set request.

\paragraph{SPADE (LLVM Instrumentation)}
SPADE can trace the function calls of certain LLVM instrumented executables. We
compiled the Redis server with LLVM instrumentation and integrated it with
SPADE. We did \emph{not} compile the Redis client with LLVM instrumentation, so
SPADE did \emph{not} trace the function calls of the client. We then ran our
simple Redis workload. SPADE produced a provenance graph with 399,916 vertices
and 718,848 edges! A sample of the information stored in these vertices is
shown in \figref{LlvmProv}.

This provenance has two shortcomings. The first is immediate; the provenance
includes an overwhelming amount of information. A single set and get request
produced over a million combined vertices and edges. If the Redis server
processed a modest ten transactions per second for one minute, it would produce
over half a \emph{billion} combined vertices and edges. Worse, interpreting
this provenance requires a deep understanding of the underlying Redis
implementation. Second, when an executable is compiled with LLVM
instrumentation, its execution is significantly slowed because every function
invocation requires the executable to report provenance information to the
SPADE server.

\paragraph{\fluent{}}
Finally, we ran our workload with \fluent{}. The \fluent{} \watprovenance{}
specification for Redis get requests is given in
\figref{ConcreteRedisProvSpec}. The Redis shim is 75 lines of C++.  \fluent{}
produced eight trace entries: a get and set request and response on both the
Redis client and the Redis server. This is four orders of magnitude more
succinct that the SPADE provenance produced by LLVM instrumentation. Moreover,
applying Redis' \watprovenance{} specification to the get request, it returns
the previous set request and nothing else.
%
% We summarize these findings in \tabref{ProvSizes}

The provenance produced by \fluent{} improves upon the provenance produced by
SPADE in two ways. First, \fluent{}'s provenance is based on the theoretical
foundations of \watprovenance{}. While kernel audits and function traces
provide low-level explanations of particular events in a system,
\watprovenance{} directly encodes our high-level understanding of \emph{why}
certain outputs are produced. Second, SPADE and similar frameworks, like
RDataTracker~\cite{lerner2014collecting} and
noWorkflow~\cite{murta2014noworkflow}, aim to produce provenance for arbitrary
black boxes. In this quest for generality, they adopt general-purpose
provenance tracing mechanisms that can be applied to any black box. For
example, compile-time instrumentation is a technique that can be applied to any
executable.  Unfortunately, the generality of these approaches causes them to
produce provenance that is too voluminous and too low-level. \Watprovenance{}
specifications sidestep this generality and instead have a developer directly
specify the \watprovenance{} of a particular black box. As a result,
\watprovenance{} specifications can produce much higher-level provenance that
is significantly more succinct. \Watprovenance{} produces only the relevant
inputs to a black box, while SPADE produces all the low-level activities that
occur \emph{within} the black box.

% {\input{figures/prov_sizes}}

\subsection{\WatProvenance{} Specifications}
In \secref{WatProvSpecs}, we described the \watprovenance{} specifications for
a number of commonly used distributed systems components such as Redis, Amazon
Z3, etc. We implemented \fluent{} \watprovenance{} specifications for Redis, a
subset of the POSIX file system API, Amazon S3, and Zookeeper. In
\tabref{ProvSpecLengths}, we list the language in which each provenance
specification is written, the lines of code required to write each
specification, and the API supported by each specification. All of the
provenance specifications are relatively short, and we found that writing the
specifications was straightforward.

\begin{table}[t]
  \caption{\fluent{} \watprovenance{} specifications}
  \tablabel{ProvSpecLengths}
  \begin{tabular}{lllp{3cm}}
    \toprule
    System    & Language & LOC & Supported API                                                         \\\midrule
    Redis     & SQL      & 30  & set, del, append, incr, decr, incrby, decrby, strlen                  \\
    POSIX     & Python   & 88  & reads and writes of byte ranges                                       \\
    Amazon S3 & Python   & 200 & creating, copying, catting, removing, and listing objects and buckets \\
    Zookeeper & SQL      & 70  & creating, reading, writing, and listing znodes                        \\
    \bottomrule
  \end{tabular}
\end{table}
