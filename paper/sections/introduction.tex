\section{Introduction}\seclabel{Introduction}
debugging distributed systems is really hard
  - explain why;
  - explain there is a lack of tooling
  - explain that people have to do ad-hoc stuff

- say that there is currently no formalism to make this line of reasoning more formal
- two candidates are causality and data provenance, but both are insufficient
- causality is very coarse grained. It doesn't incoroprate semantics, so identify a set of events which might affect another event, not the set of events which actually do affect a particular event
- Data provenance is another attrracitive offer. it does incoporate notions of semantics and returns the actual causes of an output. but it is has two limitations. first, it is defined in the realm of databases and extending it do other system componetns is not ovvious. modern distributed systems are very heterogenous consisting of a lot of differnet kinds of stuff. two, why provenance assumes a fixed database, it does not incorprate any notion of tiem varying state.

- in this paper, we propose a wat provenance, why-accross time rpovenance, as a formalism which combines the benefits of both causality and data provenance. wat provenance generalizes why provenance from fixed relational database to an arbitrary time-varying state machine. More specifically, given an arbitrary state machine, and input trace, and a particular output, the wat provenance describes why the particular output was produced. This description takes the form of a set of witnesses, subsets of the input trace, that are both necessary and sufficient and to generate the output. Like causality, wat prov can be used in an arbitrary distributed system, and like why provenacne, it returns only the events that actually do affect a certian event.

distributed systems are typically composed of two kinds of things: the stuff you write and the stuff you dont. The code you write is typically alplication sepcific business logic that you write from scratch. we call these white boxes. The cod eyou don't is typically an open source service (e.g. redis, cassandra) or a cloud service (S3, cloud spanner). These components typically have complex implementations that are either large and unfamiliar (for open source) or unavailable (for cloud). How we compute the wat provenance of a particular component is dicated by whether it is a white box or a black box.

\emph{automatically} computing the wat provenance of an arbitrary black back is intractable at best and impossible at worst. In the best case, we have to perform a very complex code analysis over a complicated piece of code. In the worst case, we don't even have access to the code at all! Fortunately, most black boxes are not arbitrary. Instead, they are designed with very simple and familiar apis. Because of this we can sidestep the problem of extracting provenance from an implementation and instead specify the provenance from an implementation. We propose wat prov specifications as a mehanism to directly specify the wat prov a black box and show that for many components (e.g. redis, cassandra, s3, ...) these specifications are simple.

White boxes, unlike black boxes, are implemented from scratch by the application designer. This raises a natural question. Does there exist a programmign alnguage in which a app writer can write their code such that we can automatically extract the data provenance? Technically yes. practically no. In this paper, we propose a simple programming language for which we can automatically extract provenance. Howoever, we also demonstrate that this language is largely inexpressive and adding expressive power to it makes it intractible. This demonstrates that automatic wat provenacne extraction is a theoretically challening problem. Fortuntaetly, there are alternatives to wat provenance that can be applied to certain classes of white boxes (e.g. network provenance) that we can use as a proxy for wat provenance.

We next turn our attention to how we convert the theoretical foundation of wat provenance into a practical tool that makes debugging heterogenous distributed systems easier than what is currently possible. We present a prototype programming framework called fluent which allows users to build debuggable distributed systems. Fluent includes a C++ dsl for writing state machines that compute their network provenance. It also includes mechanisms to write provenance specifications for black boxes. We use fluent to measure the overhead of writing wat prov specifications and also compare the fluent to existing approaches at debugging heterogenous distributed systems. We find that debugging an interaction with redis generates a graph with 300,000 or so and fluent produces one with like 10 nodes.

In summary, this paper presents the following contributions

- we define wat provenance, the first formalism to extend data provenance to the realm of arbitrary state machines. We also prove properties about wat provenance showing its soundness
- We present wat provenance specifications a mechanism to extract the wat provenance of black box systems for which automicaly extracting wat provenance is intractible or impossible
- we explore the tradeoff between programming language expressivity and wat prov extractibility and conclude that expressive languages cant be extracted and extractible languages are inexpressive. we also survey alterantives to wat prov that work well for white box
- we implement the theoretical foundation of wat prov in a system called fluent and show that it is way better than existing approaches.
