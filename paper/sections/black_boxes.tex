\section{Black Boxes}\seclabel{BlackBoxes}
now we've defined wat provenance, but how do we get it. there are two kinds of compnonents in a system: white box and black box, and the kind of thing will determine how we get the wat prove. in this section we focus on provenance specifications for getting wat prov for black boxes, in the next section we focus on wat proveannce for code you did write.


\subsection{Provenance Specifications}
given an arbitrary black box written in an arbitrary language, it is a near impossibility to efficiently extract the wat provenance in an efficient way. In order to do so, we would have take in an arbitrary piece of code and automatically infer a corresponding state machine. Then, given a trace, we would then have to perform a complex code analysis over a large body of code to infer the wat provenance. For example, Redis is over 50,000 lines of C code that we would have to analyze. Worse yet, we may not even have the source code! For example, if we use a service like S3 in the cloud, we don't even have access to the code to profile.

So, getting wat provenance for \emph{arbitrary} black is hopeless. But, we can take advantage of the fact that realistic black boxes are far from arbitrary. Most of the black boxes that we use have complex implementations but are designed with very simple APIs. This makes it very simple, sometimes trivial, for us to write wat provenance specifications: a function which given a trace, directly returns the wat provenance. For example, if we restrict our attention to the get/set API of redis, then the wat provenance of a get includes only the most recent set.

Codifying this simple specification is more or less trivial. The language in which we specify the specs is unimportant. In figure below, we write a spec for redis in python. the function takes in a trace, which is a list of things of type request, and outputs a set of witnesses, where each witness is a subsequence of the input trace. It also takes in a request and repsonse. the function simply looks for the most recent set of the same key.

figure include indexes as well

in secref..., we describe a prototype implementation of a system for collecting traces and specifying wat provenance. There, we will discuss the concrete details of doing it.

\subsection{Examples}
Redis is a particularly simple example, but there are plenty of examples of systems that are simple too

- stateless services
  - google cloud vision
  - trivial wat prov
- storage systems
  - redis with fuller api
  - most recent set plus following appends
  - s3
    - TODO: Remember
  - HDFS name node:
    - leave for alvaro to write
- coordination services
  - zookeeper
    - TODO: Remember

from s3 to ..., we see that most apis are very simple and often overlapping. For example, zookeeper by being a file system lets us leverage ideas from previous specs. This is not just a coincidence though. Systems design their APIs to be simple and familiar, meaning that many are simple to specify and many overlap.

Moreover, only one person has to write the black box spec for a particular black box, not every dev. Thus, if someone wrote a redis spec, everyone could use it. Moreover, the spec is invariant to the implementation of Redis, we do not have to change the spec every time the implementation changes. in secref eval, we see that some approaches do require that. Also, the overhead of writing these specs is significantly, significantly lower than the overhead of other existing methods, as well see in the eval section

\subsection{Checking Provenance Specifications}
Even though specs are simple, it is still possible for a user to incorrectly write a spec. Fortunately, we can write simple unit tests for wat prov specs. The main idea is that given a simple implementation of a state machine and a trace, we can manually compute the wat provenance. Then, we can check this wat provenance against the wat provenance returned by the specification. just like unit tests, this allows to sometimes conclude that the wat provenance specification is incorrect, though it never allows to say the spec is definitely correct.

An astute reader might note that this contradicts what we said earlier. We're saying we can automatically extract the wat provenance. This approach is useful for testing but not practical for getting the wat prov of a real system. The runtime of the algorithm is superexponential, meaning that for any realistically sized traces, this approach would simply not work. Still, it is useful for small unit tests.

\subsection{Limitations}
buggy black boxes:
  - we have so far tacitly assumed that a black box faithfully implements its api. If a black box is buggy, then its actual wat provenance may not be the same as what we've specified. Still, bugs in large open source projects are rare and are often fixes after being found.

nondeterministic state machines:
  - wat provenance assumes a deterministic state machine, but some state machines are nondeterministic. for example, consider a load balancer which randomly forwards traffic to servers. modelling such a thing as a deterministic state machine is impossible, so it doesn't fit our model of wat provenance very well. we think an interesting aveneue for future work will be to expand our notions of wat prov and wat prov specs to nondeterminsitic state machines

nontrivial specifications:
  - as we've noted, specifying the provenance for an arbitray black box is hard. As a contrived example, consider a server which takes in a series of programs as inputs and later returns whether one of the programs terminates. Writing a specification is tantamount to determining which of these programs terminate which is likely difficult, and undecidable in general. fortunately, many open source black boxes have simple apis, but some might be hard to specify.
