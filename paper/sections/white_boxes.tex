\newcommand{\dedalusplus}{Dedalus$^+$}

\section{White Boxes}\seclabel{WhiteBoxes}
Recall that real-world distributed systems are composed of (a) widely used
black boxes that are developed and maintained by a handful of developers and
(b) application-specific white boxes that are written from scratch. In
\secref{BlackBoxes}, we saw that automatically inferring the \watprovenance{}
of a black box is intractable. Is the same true for white boxes? Almost, but
not quite. If we implement a white box from scratch, we have the opportunity to
implement it in a programming language for which we \emph{can} automatically
extract \watprovenance{}.

In this section, we propose one such programming language. However, we also see
that this programming language is not very expressive and that making the
language more expressive forfeits our ability to easily extract
\watprovenance{}. Unfortunately, the expressiveness of a language is
fundamentally at odds with our ability to extract the \watprovenance{} of a
program written in it. Fortunately, there are some alternatives to
\watprovenance{} that we can apply to white boxes, which we discuss at the end
of this section.

\subsection{\dedalusplus}
{\input{figures/dedalus_twitter}}

Dedalus is a variant of Datalog that introduces notions of time and mutable
state~\cite{alvaro2011dedalus, marczak2012confluence, alvaro2013declarative}.
Bloom is a concrete implementation of Dedalus that has been used to program a
variety of distributed systems, including key-value stores, state machine
replication protocols, and distributed shopping
carts~\cite{alvaro2011consistency, conway2012logic}. In this section, we
describe how we can automatically extract the \watprovenance{} of a program
written in \defword{\dedalusplus}: the variant of Dedalus without negation or
deletion.

A \dedalusplus{} state machine stores its state in a collection of typed
relations, much like a relational database. Upon receiving a request, a
\dedalusplus{} state machine executes a sequence of relational expressions to
(a) update its state and (b) compute a response for the request. Notably, a
\dedalusplus{} program (unlike a Dedalus program) cannot include a relational
expression with set difference and cannot remove tuples from an existing
relation.

For example, consider the simple Twitter clone shown in \figref{DedalusTwitter}
that is written with a Python-like syntax of \dedalusplus{}. The program stores
its state in two relations: (1) \texttt{Users} which records the Twitter handle
and name of all users and (2) \texttt{Following} which records the handles that
a particular user is following. The Twitter clone supports three types of
requests:
\begin{itemize}
  \item
    A \texttt{signup(handle, name)} request creates an account with handle
    \texttt{handle} for a user named \texttt{name}.  Concretely,
    \texttt{signup} adds the tuple \texttt{(handle, name)} to the
    \texttt{Users} relation and returns an acknowledgement tuple
    \texttt{("ok")}. For example, \texttt{signup("dbguy", "Edgar Codd")}
    registers a user named Edgar Codd with handle \texttt{dbguy}.
  \item
    A \texttt{follow(me, them)} request requests that the user with handle
    \texttt{me} follows the user with handle \texttt{them}. It adds the tuple
    \texttt{(me, them)} to the \texttt{Following} relation and returns an
    acknowledgement tuple \texttt{("ok")}.
  \item
    A \texttt{following(me)} request executes a SQL query to return the names
    of every user that is being followed by the user with handle \texttt{me}.
\end{itemize}

For any execution of a \dedalusplus{} program, like the Twitter clone in
\figref{DedalusTwitter}, we can generate an accompanying \defword{provenance
graph}~\cite{alvaro2015lineage}. A provenance graph records the data
dependencies for every tuple that is created during the execution of the
program.

{\input{figures/twitter_clone_example}}

For example, consider the trace, relations, and provenance graph illustrated in
\figref{TwitterCloneExample}. The trace $T$ in \figref{TwitterCloneTrace}
consists of six requests: $r_1$ through $r_6$. Requests $r_1$ through $r_3$
register three users: Edgar Codd (\texttt{@dbguy}), Michael Jordan
(\texttt{@baller}), and Michael Jordan (\texttt{@mldude}). Requests $r_4$ and
$r_5$ are requests from Edgar Codd to follow both the Michael Jordans.  The
contents of the \texttt{Users} and \texttt{Following} relations after requests
$r_1$ through $r_5$ have been executed are shown in
\figref{TwitterCloneRelations}. Finally, the trace $T$ includes a request $r_6$
from Edgar Codd to list the names of everyone he is following. This request
returns a single tuple \texttt{(Jordan)}, and the corresponding provenance
graph for this tuple in shown in \figref{TwitterCloneProvGraph}.

The provenance graph indicates that the \texttt{(Jordan)} tuple is produced
twice: once from the join of tuples $t_4$ and $t_1$ and once from the join of
tuples $t_2$ and $t_5$. Moreover, the provenance graph indicates the request
that created each of these tuples. For example, the $r_4$ request created tuple
$t_4$, the $r_2$ request created tuple $t_1$, etc.

The \watprovenance{} of the \texttt{following(dbguy)} request is the set
$\set{T_{24}, T_{35}}$ of two witnesses $T_{24} = r_2r_4$ and $T_{35} =
r_3r_5$. These two witnesses are exactly the two witnesses that we get if we
walk backwards through the provenance graph in \figref{TwitterCloneProvGraph}
beginning at our output tuple \texttt{Jordan}. This is not a coincidence. Given
any output produced by a state machine written in \dedalusplus{}, we can always
walk backwards through the provenance graph rooted at the output and
efficiently extract the corresponding \watprovenance{}.

\subsection{Limitations and Alternatives}
Automatically extracting the \watprovenance{} of a state machine implemented in
\dedalusplus{} is theoretically interesting but only marginally practical.
While Dedalus can be used to implement a number of complex distributed systems,
\dedalusplus{} is a very narrow restriction of Dedalus that is not expressive
enough for many common programming idioms due to its lack of negation and
deletion. For example, we are unable to add a request to our \dedalusplus{}
Twitter clone that unfollows a particular user because we are unable to remove
from the \texttt{Following} relation.

If we reintroduce negation and deletion into \dedalusplus{}, we get back the
full expressive power of Dedalus. But, doing so makes it difficult to extract
\watprovenance{}. In particular, there is no commonly accepted way to construct
a provenance graph for a program that includes negation. As a result,
constructing a provenance graph for a Dedalus program and extracting the
\watprovenance{} from it becomes significantly more complicated.

Fortunately, there are alternatives to \watprovenance{} that are well suited to
programs written in Datalog variants like Dedalus. In particular, network
provenance~\cite{zhou2010efficient, zhou2011secure, zhou2012distributed}
formalizes a notion of time-varying provenance for distributed systems written
in Datalog variants, and there is existing literature on how to compute network
provenance efficiently~\cite{zhou2010efficient, zhou2012distributed} and with
low space overheads~\cite{chen2017distributed}.

Still, network provenance is only applicable to white boxes written in a
variant of Datalog, and realistically most business logic is written in a more
mainstream programming language like C++ or Java. For white boxes written in a
more traditional programming language, an application developer has two options
for extracting \watprovenance{}. The first is to treat the white box as a black
box and write a \watprovenance{} specification, as detailed in
\secref{BlackBoxes}. The second is to resort to ad-hoc debugging using a
debugger like GDB. This second approach is not ideal, but because white boxes
are written from scratch, the application developer has the benefit of being
familiar with the code (unlike with a large black box, for which ad-hoc
debugging is typically overwhelmingly onerous).
