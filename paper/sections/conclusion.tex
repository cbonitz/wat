\section{Discussion}\seclabel{Discussion}

In Section~\secref{WatProvSpects}, we showed how easy it was to write shims
for a variety of common black box components.  In return for this modest
investment, \fluent{}  allowed programmers to ask and answer debugging questions
that span node boundaries and involve mutable state that changes over time.
It is tempting to ask if we can take the idea further.  If our components are
written in a language amenable to provenance collection, could we infer their
black box specifications automatically?  Or, better still, could we obtain
richer provenance that explains not just which input tuples contributed to
an output tuple, but precisely how?  While black box provenance helps take
a distributed debugging problem and narrow it down to debugging a single
component, this ``white box'' approach would allow us to identify and repair
bugs inside components.

Unfortunately, automatically capturing white box WAT provenance seems elusive.
Provenance-enhanced distributed logic programming languages such as NDLog and
Dedalus each expose a form of why-provenance that accounts for state that
changes over time.  In NDLog, effectful events such as the addition, deletion or update of records are reified into the provenance graph.  In Dedalus, logical
time is reified into all of the records.  These custom representations of
provenance in time, while not formalized, are similar in spirit to WAT provenance.
It turns out, however, that they are not equivalent to it---neither Dedalus nor
NDLog provenance necessarily identify minimal witnesses.  The underlying issue
is the problem of the \emph{negative provenance} or the provenance of
non-answers~\cite{chapman2009whynot,huang2008nonanswers}, which remains an open problem in
the database research community.

\newcommand{\kvset}{\text{set}}
\newcommand{\kvget}{\text{get}}
\newcommand{\freeze}{\text{freeze}}
\newcommand{\trunc}{\text{trunc}}

Consider the KVS state machine presented in Example\exampleref{WatExampleKVS}, extended to support two new calls.   \texttt{freeze} makes the existing set of keys and values immutable, while \texttt{trunc} deletes all of the keys and values (provided that \texttt{freeze} has not been called.)  Now consider the trace

\[
  T = a_1 a_2 a_3 = \kvset(x,1), \freeze, \trunc
\]

The WAT provenance of $i = \kvget(x)$ is $\{a_1, a_2\}$.  But explaining why $a_2$ is part of the witness set requires reasoning about non-answers: $x$ had the value $1$ both because of $a_1$,
which inserted the value into the store, and because $a_3$ had no effect (due to the action of $a_2$, without which $a_3$ would have removed the effects of $a_1$!)
If the state machine was written in a language such as NDLog or Dedalus, implementing it would require the use of logical negation (in fact, examples 4-6 all require nonmonotonic logic) and explanations of its outputs would require both positive and negative provenance.  Explaining why a particular event \emph{did not occur} is intractable in general, as the explanation may be infinitely large.  Existing techniques for collecting negative provenance apply heuristics that (finitely) over-approximate the why provenance of non-answers.  For example, Dedalus provenance would determine that the provenance of $i$ is $\{a_1, a_2, a_3\}$.

We could, of course, constrain the programming language to rule out the complication of negative provenance.  The language Dedalus+\cite{marczak2012confluence} is the positive fragment of Dedalus, in which negation is not permitted (except on base relations).    Programs written in Dedalus+ generate positive why-provenance graphs whose leaves correspond exactly with the WAT provenance of the given execution. Unfortunately, Dedalus+ is not adequately expressive to implement arbitrary stateful distributed services.  The CALM theorem~\cite{alvaro2011consistency,ameloot2013transducers} guarantees that Dedalus+ programs produce deterministic outputs under all input orders \emph{precisely because} those programs do not use negation.  By the same token, programs whose outputs are (by definition) influenced by their input orders---such as key/value stores, file systems and object stores, caches, etc---cannot be implemented in a logic language without using negation!

In short, fully automatic collection of WAT provenance for general-purpose systems seems tricky, but programmer-assisted WAT provenance IS A-OK.  For consistent-by-construction systems written in monotonic logic languages, \fluent{} can automatically extract rich WAT provenance and compose it provenance obtained from black box specifications.  For systems written in arbitrary provenance-enhanced languages, \fluent{} can collect non-minimal witness sets to assist in intra-component debugging.  For a small additional investment, a programmer can supply a black box specification to filter the irrelevant witnesses, getting the best of both worlds.

\todo{joe wants better wrapup here!}


\section{Conclusion}\seclabel{Conclusion}
This paper identified inadequacies in existing formalisms that are used to
reason about the causes of events in distributed systems. Causality
overapproximates the true cause of an event, and data provenance is restricted
to the domain of static relational databases.  We then presented
\watprovenance{}: a novel form of provenance that generalizes \whyprovenance{}
and refines causality. \Watprovenance{} formalizes precisely why a particular
state machine produces a particular output with respect to a previously
executed trace of inputs. We then discussed how to sidestep the complexity of
automatic \watprovenance{} extraction with \watprovenance{} specifications,
which we found to be simple to write in practice due to the fact that most
distributed systems components have simple interfaces. We implemented our
theoretical findings in a system called \fluent{} and found it to produce
lineage that is orders of magnitude more succinct than existing tools targeted
at debugging distributed systems.

\begin{acks}
  The authors would like to thank Sanjay Krishnan, Alvin Cheung, and Anthony
  Tan for fruitful discussion and feedback.
  %
  This research is supported in part by DHS Award HSHQDC-16-3-00083, NSF CISE
  Expeditions Award CCF-1139158, and gifts from Alibaba, Amazon Web Services, Ant
  Financial, CapitalOne, Ericsson, GE, Google, Huawei, Intel, IBM, Microsoft,
  Scotiabank, Splunk and VMware.
\end{acks}
