\section{Related Work}\seclabel{RelatedWork}
% \jmh{Adrian Colyer did a week on distributed tracing back in 10/6/2015. See https://blog.acolyer.org/2015/10/page/2/}
%
% \jmh{Would be good to give a nod to Bailis' SoCC paper and also the refs in it on explicit causality~\cite{bailis2012potential}}
%
Provenance is a broad and far-reaching concept that has been researched by the
database, distributed systems, and scientific workflow communities. In this
section, we summarize the most relevant research from these fields.

\paragraph{Black Box Provenance}
RDataTracker \cite{lerner2014collecting}, noWorkflow
\cite{murta2014noworkflow}, and SPADE \cite{gehani2012spade} are frameworks
that attempt to record the provenance of data through an \emph{arbitrary} black
box using general purpose low-level provenance tracing techniques. RDataTracker
and noWorkflow use reflection and runtime information to track the provenance
of data through minimally annotated R and Python scripts. SPADE collects
provenance information from operating system audit logs, network artifacts,
LLVM instrumented applications, and applications dynamically instrumented for
taint analysis. The benefit of these frameworks is their generality. However,
their generality comes at the cost of verbosity. These provenance frameworks
produce a large amount of low-level implementation-specific provenance
information that can be challenging to interpret.

\paragraph{Data-Dependent Process Provenance}
A data-dependent process (DDP) is a finite state machine in which certain
transitions are determined by the result of evaluating a query against an
accompanying relational database while other transitions are triggered by
external requests~\cite{deutch2014provenance, deutch2015provenance}. In
\cite{deutch2014provenance} and \cite{deutch2015provenance}, Deutch et al.\
extend provenance semirings~\cite{green2007provenance} to linear temporal logic
formulas issued against a DDP.
%
Both DDP provenance and \watprovenance{} aim to extend traditional data
provenance to state machines, but they do so in very different ways. DDP
provenance is used to explain how particular execution traces may arise.
%
% For example, DDP provenance might inform us about the database contents under
% which a particular state in the DDP can be reached.
%
\Watprovenance{}, on the other hand, aims to explain why a particular output
was generated with respect to a fixed trace of inputs. DDPs are also assumed to
be finite and backed by relational databases, while \watprovenance{} targets
arbitrary (even infinite) deterministic state machines.

\paragraph{Network Provenance}
Network provenance was originally introduced in~\cite{zhou2010efficient} as a
generalization of data provenance to programs written in the extended
relational language NDLog~\cite{loo2006design}. ExSPAN~\cite{zhou2010efficient}
and DistTape~\cite{zhou2012distributed} are two accompanying implementations
that record the network provenance of a distributed system implemented in
NDLog.
%
The network provenance of a piece of data is tied to the particular NDLog
program that created it, whereas \watprovenance{} is defined with respect to
abstract state machines instead of concrete implementations. As a result,
network provenance provides finer grained debugging information than
\watprovenance{}, but is applicable only to systems written in NDLog.
\Watprovenance{} provides coarser grained debugging information, but is
applicable to arbitrary state machines.

\paragraph{Scientific Workflow Systems}
Scientific workflow systems like Taverna \cite{wolstencroft2013taverna}, Kepler
\cite{altintas2006provenance}, Pegasus \cite{kim2008provenance}, and Swift
\cite{wozniak2013swift} can be used to structure complex computational tasks as
a graph, composing tasks by connecting the outputs of one task to the inputs of
another. These systems are limited to the workflow languages that they support,
and these languages are not typically used to build distributed systems. They
also assume that the inputs to a workflow are static. \Watprovenance{}
formalizes provenance for arbitrary distributed systems composed of
time-varying state machines.

\paragraph{DISC Provenance}
Data intensive scalable computing (DISC) frameworks like Apache
Hadoop~\cite{shvachko2010hadoop} and Apache Spark~\cite{zaharia2010spark} can
execute data-parallel programs on massive amounts of data both efficiently and
with fault tolerance. Work on GMRW provenance~\cite{ikeda2011provenance} and
systems like BigDebug~\cite{gulzar2016bigdebug},
Titian~\cite{interlandi2015titian}, and RAMP~\cite{park2011ramp} augment DISC
frameworks like Hadoop and Spark with data provenance. DISC provenance is
similar to the provenance produced by scientific workflow systems. It is
restricted to the domain of data intensive computations over static data.
Unlike \watprovenance{}, it cannot be applied to other distributed systems
components like storage systems, coordination services, load balancers, etc.

\paragraph{Distributed Tracing Tools}
Distributed tracing tools like Dapper~\cite{sigelman2010dapper},
X-trace~\cite{fonseca2007x}, Magpie~\cite{barham2003magpie},
Stardust~\cite{thereska2006stardust}, and lprof~\cite{zhao2014lprof} allow
programmers to trace messages through large and complex distributed systems
that span multiple nodes and administrative domains. These traces enable
programmers to answer many useful debugging questions (e.g.\ ``When a client
issues a request, which nodes are contacted before a reply is returned?''). The
fundamental distinction between distributed traces and \watprovenance{} is that
distributed traces do not carry historical information that link prior inputs
to present outputs. For example, traces may show you which clients contacted a
key-value store and when, but they will not show you which requests wrote the
values that later requests read back.
%
Also note that lprof, unlike other tracing tools, constructs traces by
analyzing systems' existing logs; it does not require any program
instrumentation. In the future, we plan to explore whether we can use a similar
technique to construct traces from a system's existing logs.
