\section{Related Work}\seclabel{RelatedWork}
\jmh{Adrian Colyer did a week on distributed tracing back in 10/6/2015. See https://blog.acolyer.org/2015/10/page/2/}

\jmh{Would be good to give a nod to Bailis' SoCC paper and also the refs in it on explicit causality~\cite{bailis2012potential}}

Provenance is a broad and far-reaching concept that has been researched by the
database, distributed systems, and scientific workflow communities. In this
section, we summarize the most relevant research from these fields.

\paragraph{Black Box Provenance}
RDataTracker~\cite{lerner2014collecting},
noWorkflow~\cite{murta2014noworkflow}, and SPADE~\cite{gehani2012spade} are
frameworks that attempt to record the provenance of data through an
\emph{arbitrary} black box using general purpose low-level provenance
tracing techniques. RDataTracker and noWorkflow use reflection and runtime
information to track the provenance of data through minimally annotated R and
Python scripts. SPADE collects provenance information from a variety of sources
including operating system audit logs, network artifacts, LLVM instrumented
applications, and applications dynamically instrumented for taint analysis. The
benefit of these frameworks is their generality. They can be applied to
\emph{any} piece of code. However, their generality is also their undoing. As
we saw in \secref{Evaluation}, these provenance frameworks produce an
overwhelming amount of very low-level implementation-specific provenance
information that is challenging to interpret. \watprovenance{} specifications
sidestep these low-level details and directly specify the relevant
\watprovenance{} of a black box.

\paragraph{Network Provenance}
Network provenance was originally introduced in~\cite{zhou2010efficient} as a
generalization of data provenance to programs written in NDLog, a language
similar to Dedalus. ExSPAN~\cite{zhou2010efficient} and
DistTape~\cite{zhou2012distributed} are two accompanying implementations that
record the network provenance of a distributed system implemented in NDLog.
\fluent{} borrows many of the implementation details from these two systems to
record the network provenance of distributed systems written in \fluent{}'s
white box programming language. For example, \fluent{} stores relation
histories and network provenance using a hash-based relational format that was
originally implemented in ExSPAN. DistTape also offers additional optimizations
that we have not yet implemented in \fluent{}~\cite{zhou2012distributed,
chen2017distributed}.
% For example, DistTape can record network provenance using one of two schemes.
% Using a proactive scheme, all provenance updates are eagerly logged. Using a
% reactive scheme, only non-deterministic events are logged, and the missing
% state is reconstructed using deterministic replay.
This paper generalizes network provenance with \watprovenance{}, stepping
beyond NDLog programs to arbitrary state machines. The majority of real-world
distributed systems are not implemented in pure NDLog, and \watprovenance{}
provides a formalism for reasoning about the provenance of these non-NDLog
components.

\paragraph{Data-Dependent Process Provenance}
A data-dependent process (DDP) is a finite state machine in which certain
transitions are determined by the result of evaluating a query against an
accompanying relational database while other transitions are triggered by
external requests~\cite{deutch2014provenance, deutch2015provenance}. In
\cite{deutch2014provenance} and \cite{deutch2015provenance}, Deutch et al.\
extend provenance semirings~\cite{green2007provenance} to linear temporal logic
formulas issued against a DDP.
%
Both DDP provenance and \watprovenance{} aim to extend traditional data
provenance to state machines, but they do so in very different ways. DDP
provenance is used to explain how particular execution traces may arise. For
example, DDP provenance might inform us about the database contents under which
a particular state in the DDP can be reached. \Watprovenance{}, on the other
hand, aims to explain why a particular output was generated with respect to a
particular trace of inputs. DDPs are also assumed to be finite and backed by
relational databases, while \watprovenance{} targets arbitrary (even infinite)
state machines.

\paragraph{Scientific Workflow Systems}
Scientific workflow systems like Taverna~\cite{wolstencroft2013taverna},
Kepler~\cite{altintas2006provenance}, Pegasus~\cite{kim2008provenance}, and
Swift~\cite{wozniak2013swift} can be used to structure complex computational
tasks as a graph, composing tasks by connecting the outputs of one task to the
inputs of another. These systems are limited to the workflow languages that
they support, but these languages are not typical programming models for
distributed systems. They also assume that the inputs to a workflow are
static.  \watprovenance{} formalizes provenance for arbitrary distributed
systems composed of time-varying state machines.

\paragraph{DISC Provenance}
Data intensive scalable computing (DISC) frameworks like Apache
Hadoop~\cite{shvachko2010hadoop} and Apache Spark~\cite{zaharia2010spark} can
execute data-parallel programs on massive amounts of data both efficiently and
with fault tolerance. Debugging programs executed by these frameworks can be
challenging because it can be difficult to pinpoint which subset of the massive
input data triggered some buggy behaviour. In efforts to reduce this burden,
work on GMRW provenance~\cite{ikeda2011provenance} and systems like
BigDebug~\cite{gulzar2016bigdebug}, Titian~\cite{interlandi2015titian}, and
RAMP~\cite{park2011ramp} augment DISC frameworks like Hadoop and Spark with
data provenance. DISK provenance is similar to the provenance produced by
scientific workflow systems. It is restricted to the domain of data intensive
computations over static data.  Unlike \watprovenance{}, it cannot be applied
to other distributed systems components like storage systems, coordination
services, load balancers, etc.

\paragraph{Distributed Tracing Tools}
Distributed tracing tools like Dapper~\cite{sigelman2010dapper},
X-trace~\cite{fonseca2007x}, Magpie~\cite{barham2003magpie}, and
Stardust~\cite{thereska2006stardust} allow programmers to trace messages
through large and complex distributed systems that span multiple nodes and
administrative domains. These traces enable programmers to answer many of the
same questions that provenance graphs do (e.g.\ ``When a client issues a
request, which nodes are contacted before a reply is returned?''). However, the
fundamental distinction between distributed traces and provenance graphs is
that distributed traces do not carry historical information which causally
links prior inputs to present outputs. For example, traces may show you which
clients contacted a key-value store and when, but they won't show you which
requests wrote the values that later requests read back.

\paragraph{Asynchronous Declarative Programming Languages}
\jmh{If we decide that we need to keep this section, it needs work.}
\fluent{}'s white box programming framework is inspired by the
Dedalus~\cite{alvaro2011dedalus}, Bloom~\cite{alvaro2011consistency,
conway2012logic}, Overlog~\cite{loo2005implementing}, and
NDLog~\cite{loo2009declarative} programming languages which implement a
asychronous declarative programming paradigm.
